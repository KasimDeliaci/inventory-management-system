-- ======================================================================
-- V6__sales_tables.sql  (PostgreSQL 17.6)
-- Depends on:
--   • V1__types.sql            (sales_order_status)
--   • V2__core_master_tables   (products, customers)
--   • V4__campaign_tables.sql  (campaigns, campaign_products, customer_special_offers)
-- Purpose :
--   Record customer sales orders (no partial shipments for PoC).
--   Unit price & final discount snapshotted at line-time.
--   Money is DB-computed to avoid drift (one rounding rule).
-- ----------------------------------------------------------------------
--  Pricing & Discount Engine (SERVICE LOGIC – documented here for clarity)
--  ---------------------------------------------------------------------
--  Active window: order_date BETWEEN start_date AND end_date (inclusive).
--
--  1) Product campaign percent (productPct) for a line (productId, qty):
--     • No active campaign on order_date                -> productPct = 0
--     • Type = 'DISCOUNT':
--           if (min_qty IS NULL OR qty >= min_qty)      productPct = discount_percentage
--           else                                        productPct = 0
--     • Type = 'BXGY_SAME_PRODUCT' (countable UoMs only: adet, koli, paket, çuval, şişe):
--           group = buy_qty + get_qty
--           free  = floor(qty / group) * get_qty
--           productPct = round( (free::numeric / qty) * 100, 2 )
--           (Optionally: if qty < min_qty then productPct = 0)
--
--  2) Customer offer percent (customerPct) from header snapshot:
--     • If one active offer exists on order_date        -> customerPct = percent_off
--     • Else                                            -> customerPct = 0
--
--  3) Combine via STACKING (chosen policy for PoC):
--        combined = 1 - (1 - productPct/100) * (1 - customerPct/100)
--        discount_percentage (persisted on line) = round(combined * 100, 2)
--     • Optional cap (NOT used in PoC): e.g., min(combinedPct, 50.00)
--
--  4) Money rounding (DB once per line):
--        discount_amount = round(quantity * unit_price * discount_percentage / 100, 2)
--        line_total      = round(quantity * unit_price * (1 - discount_percentage/100), 2)
--        (Do not re-round in application code.)
--
--  Deletion policy:
--     • sales_orders.customer_special_offer_id : ON DELETE SET NULL (audit kept via pct snapshot).
--     • sales_order_items.campaign_id          : ON DELETE SET NULL (line keeps final %).
-- ======================================================================

-- =========================
-- SALES ORDERS (header)
-- =========================
CREATE TABLE IF NOT EXISTS sales_orders (
  sales_order_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id    BIGINT NOT NULL REFERENCES customers(customer_id),

  order_date     DATE        NOT NULL DEFAULT CURRENT_DATE,
  delivery_date  DATE        NOT NULL,          -- planned ETA (required)
  delivered_at   timestamptz,                   -- actual timestamp on DELIVERED

  status         sales_order_status NOT NULL DEFAULT 'PENDING',

  -- Optional snapshot of customer offer (FK nulls if offer is deleted)
  customer_special_offer_id     BIGINT
                                  REFERENCES customer_special_offers(special_offer_id)
                                  ON DELETE SET NULL,
  customer_discount_pct_applied NUMERIC(5,2)
    CHECK (customer_discount_pct_applied IS NULL OR (customer_discount_pct_applied BETWEEN 0 AND 100)),

  created_at     timestamptz NOT NULL DEFAULT now(),
  updated_at     timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT chk_so_dates CHECK (
    delivery_date >= order_date
    AND (delivered_at IS NULL OR delivered_at >= (order_date::timestamptz))
  ),
  CONSTRAINT chk_so_delivered_pair CHECK (
    (status = 'DELIVERED' AND delivered_at IS NOT NULL)
    OR
    (status <> 'DELIVERED' AND delivered_at IS NULL)
  )
);

-- Indexes for list screens & dashboards
CREATE INDEX IF NOT EXISTS idx_so_customer        ON sales_orders (customer_id);
CREATE INDEX IF NOT EXISTS idx_so_status          ON sales_orders (status);
CREATE INDEX IF NOT EXISTS idx_so_order_date      ON sales_orders (order_date);
CREATE INDEX IF NOT EXISTS idx_so_eta_board
  ON sales_orders (delivery_date)
  WHERE status IN ('PENDING','ALLOCATED','IN_TRANSIT');
CREATE INDEX IF NOT EXISTS idx_so_customer_offer  ON sales_orders (customer_special_offer_id);
CREATE INDEX IF NOT EXISTS idx_so_delivered_since
  ON sales_orders (delivered_at)
  WHERE delivered_at IS NOT NULL;

-- =========================
-- SALES ORDER ITEMS
-- =========================
CREATE TABLE IF NOT EXISTS sales_order_items (
  sales_order_item_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sales_order_id      BIGINT NOT NULL
                         REFERENCES sales_orders(sales_order_id) ON DELETE CASCADE,
  product_id          BIGINT NOT NULL REFERENCES products(product_id),

  quantity            NUMERIC(12,3) NOT NULL CHECK (quantity > 0),
  unit_price          NUMERIC(12,2) NOT NULL CHECK (unit_price >= 0),

  -- Final % after combining campaign (productPct) ± customer offer (customerPct)
  discount_percentage NUMERIC(5,2) NOT NULL DEFAULT 0
                        CHECK (discount_percentage >= 0 AND discount_percentage <= 100),

  -- Attribution: which campaign influenced this line (nullable pointer)
  campaign_id         BIGINT REFERENCES campaigns(campaign_id) ON DELETE SET NULL,

  -- DB-computed money (single rounding rule)
  discount_amount     NUMERIC(14,2)
                        GENERATED ALWAYS AS (round(quantity * unit_price * discount_percentage / 100, 2)) STORED,
  line_total          NUMERIC(14,2)
                        GENERATED ALWAYS AS (round(quantity * unit_price * (1 - discount_percentage/100), 2)) STORED,

  created_at          timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT uq_soi_unique_product_per_so UNIQUE (sales_order_id, product_id)
);

-- Query helpers
CREATE INDEX IF NOT EXISTS idx_soi_product  ON sales_order_items (product_id);
CREATE INDEX IF NOT EXISTS idx_soi_campaign ON sales_order_items (campaign_id) WHERE campaign_id IS NOT NULL;

-- ----------------------------------------------------------------------
-- Comments (keep the “why” close to the data)
-- ----------------------------------------------------------------------
COMMENT ON TABLE  sales_orders IS
  'Sales order header. delivery_date = planned ETA (required). delivered_at = actual on DELIVERED. '
  'customer_special_offer_id uses ON DELETE SET NULL; the applied percent is persisted in customer_discount_pct_applied.';
COMMENT ON COLUMN sales_orders.customer_discount_pct_applied IS
  'Snapshot of percent-off from customer offer at order time (audit). Persists even if the FK is nulled.';
COMMENT ON TABLE  sales_order_items IS
  'Sales lines with unit_price snapshot and final discount_percentage (STACKING of product campaign and customer offer). '
  'campaign_id is a nullable attribution pointer; money columns are DB-generated with 2-dec rounding.';
COMMENT ON COLUMN sales_order_items.campaign_id IS
  'Nullable FK to the product campaign used at order time (service must ensure product assignment + active window).';
COMMENT ON COLUMN sales_order_items.discount_percentage IS
  'Final percent: combined = 1 - (1 - productPct/100)*(1 - customerPct/100); stored as round(combined*100, 2).';