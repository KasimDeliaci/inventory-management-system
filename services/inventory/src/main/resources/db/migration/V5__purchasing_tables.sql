-- ======================================================================
-- V4__purchase_orders.sql   (PostgreSQL 17.6)  -- partial receipts enabled
-- Depends on: V1__types.sql (purchase_order_status), V2 core tables
-- ======================================================================

-- =========================
-- PURCHASE ORDERS (header)
-- =========================
CREATE TABLE IF NOT EXISTS purchase_orders (
  purchase_order_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  supplier_id       BIGINT NOT NULL REFERENCES suppliers(supplier_id),

  order_date        DATE        NOT NULL DEFAULT CURRENT_DATE,  -- schedule date
  expected_delivery DATE,                                       -- ETA (suggest at UI)
  actual_delivery   timestamptz,                                -- set when RECEIVED

  status            purchase_order_status NOT NULL DEFAULT 'PLACED',

  created_at        timestamptz NOT NULL DEFAULT now(),
  updated_at        timestamptz NOT NULL DEFAULT now(),

  -- Date hygiene
  CONSTRAINT chk_po_dates CHECK (
    (expected_delivery IS NULL OR expected_delivery >= order_date)
    AND (actual_delivery   IS NULL OR actual_delivery::date >= order_date)
  ),

  -- ETA presence and consistency with status
  CONSTRAINT chk_po_eta_required_in_transit CHECK (
    status <> 'IN_TRANSIT'::purchase_order_status OR expected_delivery IS NOT NULL
  ),
  CONSTRAINT chk_po_eta_after_received_forbidden CHECK (
    status <> 'RECEIVED'::purchase_order_status OR expected_delivery IS NULL OR expected_delivery <= actual_delivery::date
  ),

  -- If you mark RECEIVED, require an actual_delivery timestamp
  CONSTRAINT chk_po_actual_on_received CHECK (
    (status = 'RECEIVED' AND actual_delivery IS NOT NULL)
    OR
    (status <> 'RECEIVED' AND actual_delivery IS NULL)
  )
);

-- Indexes for list screens & dashboards
CREATE INDEX IF NOT EXISTS idx_po_supplier       ON purchase_orders (supplier_id);
CREATE INDEX IF NOT EXISTS idx_po_status         ON purchase_orders (status);
CREATE INDEX IF NOT EXISTS idx_po_order_date     ON purchase_orders (order_date);
CREATE INDEX IF NOT EXISTS idx_po_expected_date  ON purchase_orders (expected_delivery);

-- “Arriving soon” (open POs by ETA)
CREATE INDEX IF NOT EXISTS idx_po_open_by_eta
  ON purchase_orders (expected_delivery)
  WHERE status IN ('IN_TRANSIT');

-- =========================
-- PURCHASE ORDER ITEMS
-- =========================
CREATE TABLE IF NOT EXISTS purchase_order_items (
  purchase_order_item_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  purchase_order_id      BIGINT NOT NULL
                           REFERENCES purchase_orders(purchase_order_id) ON DELETE CASCADE,
  product_id             BIGINT NOT NULL REFERENCES products(product_id),

  quantity_ordered   NUMERIC(12,3) NOT NULL CHECK (quantity_ordered > 0),
  quantity_received  NUMERIC(12,3) NOT NULL DEFAULT 0
                      CHECK (quantity_received >= 0 AND quantity_received <= quantity_ordered),

  unit_price         NUMERIC(12,2) NOT NULL CHECK (unit_price >= 0),

  -- Ordered value (budget/plan)
  line_total         NUMERIC(14,2)
                      GENERATED ALWAYS AS (round(quantity_ordered  * unit_price, 2)) STORED,

  -- Actually received value (what you’ll consider as landed for cost dashboards)
  line_total_received NUMERIC(14,2)
                      GENERATED ALWAYS AS (round(quantity_received * unit_price, 2)) STORED,

  created_at         timestamptz NOT NULL DEFAULT now(),

  -- One product per PO line (simple, standard)
  CONSTRAINT uq_poi_unique_product_per_po UNIQUE (purchase_order_id, product_id)
);

-- Item indexes
-- (Unique constraint above creates a (purchase_order_id, product_id) index,
--  which already accelerates "list items for PO". No need for a separate (po_id) index.)
CREATE INDEX IF NOT EXISTS idx_poi_product_id  ON purchase_order_items (product_id);