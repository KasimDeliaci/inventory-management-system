-- ======================================================================
-- V7__stock_tables.sql  (PostgreSQL 17.6)
-- Purpose: 1) stock_movements = immutable audit, 2) current_stock = fast snapshot
-- Notes: No DB triggers; service posts movement + updates snapshot in one TX.
-- ======================================================================

-- Service notes:
-- Reserve: UPDATE current_stock SET quantity_reserved = quantity_reserved + :qty WHERE product_id=:p AND (quantity_on_hand - quantity_reserved) >= :qty;
-- Receive (PO): INSERT stock_movements(..., PURCHASE_RECEIPT, ...); UPDATE current_stock SET quantity_on_hand = quantity_on_hand + :qty, last_movement_id=:mid, last_updated=now() WHERE product_id=:p;
-- Deliver (SO): INSERT stock_movements(..., SALE_SHIPMENT, ...);   UPDATE current_stock SET quantity_on_hand = quantity_on_hand - :qty, quantity_reserved = quantity_reserved - :qty, last_movement_id=:mid, last_updated=now() WHERE product_id=:p;
-- Adjustment OUT: only if (quantity_on_hand - quantity_reserved) >= :qty.

-- ======================================================================
-- STOCK MOVEMENTS (append-only audit)
-- ======================================================================
DROP TABLE IF EXISTS stock_movements CASCADE;
CREATE TABLE stock_movements (
  movement_id   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id    BIGINT NOT NULL,

  movement_kind   movement_kind   NOT NULL,  -- PURCHASE_RECEIPT | SALE_SHIPMENT | ADJUSTMENT_IN | ADJUSTMENT_OUT
  movement_source movement_source NOT NULL,  -- PURCHASE_ORDER | SALES_ORDER | ADJUSTMENT

  -- Polymorphic link to order header/line (NULL only for ADJUSTMENT kind)
  source_id      BIGINT,
  source_item_id BIGINT,

  -- Always positive; direction comes from movement_kind
  quantity       NUMERIC(12,3) NOT NULL CHECK (quantity > 0),

  movement_date  timestamptz NOT NULL DEFAULT now(),  -- business time
  created_at     timestamptz NOT NULL DEFAULT now(),  -- audit time

  -- Keep audit on product delete (block delete if history exists)
  CONSTRAINT fk_sm_product
    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE RESTRICT,

  -- PO/SO must have BOTH source ids; ADJUSTMENT must have NONE
  CONSTRAINT chk_source_required CHECK (
    (movement_source IN ('PURCHASE_ORDER','SALES_ORDER')
       AND source_id IS NOT NULL AND source_item_id IS NOT NULL)
    OR
    (movement_source = 'ADJUSTMENT'
       AND source_id IS NULL AND source_item_id IS NULL)
  ),

  -- Enforce source↔kind consistency (no receipt from SALES_ORDER etc.)
  CONSTRAINT chk_kind_by_source CHECK (
    (movement_source <> 'PURCHASE_ORDER' OR movement_kind = 'PURCHASE_RECEIPT') AND
    (movement_source <> 'SALES_ORDER'    OR movement_kind = 'SALE_SHIPMENT') AND
    (movement_source <> 'ADJUSTMENT'     OR movement_kind IN ('ADJUSTMENT_IN','ADJUSTMENT_OUT'))
  )
);

-- By-product timeline (latest first) → product drilldown screens
CREATE INDEX idx_sm_product_date
  ON stock_movements (product_id, movement_date DESC);

-- All movements for a single order header (PO/SO) → trace an order
CREATE INDEX idx_sm_source_pair
  ON stock_movements (movement_source, source_id);

-- Movements for a specific order line → line-level traceability
CREATE INDEX idx_sm_source_item
  ON stock_movements (movement_source, source_item_id);

-- Idempotency for one-shot receive/deliver (prevents double-posting same line)
DROP INDEX IF EXISTS uq_sm_one_per_source_line;
CREATE UNIQUE INDEX uq_sm_one_per_source_line
  ON stock_movements (movement_source, source_item_id, movement_kind)
  WHERE source_item_id IS NOT NULL;


-- ======================================================================
-- CURRENT STOCK (per-product snapshot)
-- ======================================================================
DROP TABLE IF EXISTS current_stock CASCADE;
CREATE TABLE current_stock (
  product_id         BIGINT PRIMARY KEY,

  quantity_on_hand   NUMERIC(12,3) NOT NULL DEFAULT 0 CHECK (quantity_on_hand >= 0), -- physical
  quantity_reserved  NUMERIC(12,3) NOT NULL DEFAULT 0 CHECK (quantity_reserved >= 0), -- app-held

  -- Derived: available = on_hand - reserved (cannot be written directly)
  quantity_available NUMERIC(12,3)
                       GENERATED ALWAYS AS (quantity_on_hand - quantity_reserved) STORED,

  -- Pointer to last movement for quick “what changed me last?”
  last_movement_id   BIGINT REFERENCES stock_movements(movement_id),

  last_updated       timestamptz NOT NULL DEFAULT now(),

  -- No backorders: available must be >= 0
  CONSTRAINT fk_cs_product
    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE RESTRICT,
  CONSTRAINT chk_available_nonneg CHECK (quantity_on_hand >= quantity_reserved)
);

-- “Low/negative stock” lists → quick scan on dashboards
CREATE INDEX idx_cs_available
  ON current_stock (quantity_available);

-- “Recently touched products” → sync widgets / admin views
CREATE INDEX idx_cs_last_updated
  ON current_stock (last_updated DESC);